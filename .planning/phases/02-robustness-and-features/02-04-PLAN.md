---
phase: 02-robustness-and-features
plan: 04
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - claude-tasks/src/staleness.rs
  - claude-tasks/src/state.rs
  - claude-tasks/src/lib.rs
  - claude-tasks/src/commands.rs
  - claude-tasks/src/sync.rs
autonomous: true

must_haves:
  truths:
    - "Header todo shows 'STALE (Xm)' when no updates for 15 minutes"
    - "Staleness duration is displayed in human-readable format (23m, 1h5m)"
    - "Staleness indicator clears silently when updates resume"
    - "Staleness threshold is configurable via config file"
  artifacts:
    - path: "claude-tasks/src/staleness.rs"
      provides: "StalenessTracker with record_update, check_staleness, format_staleness"
      min_lines: 50
    - path: "claude-tasks/src/commands.rs"
      provides: "update_header_command for staleness updates"
      contains: "update_header"
  key_links:
    - from: "claude-tasks/src/lib.rs"
      to: "staleness::StalenessTracker"
      via: "Staleness checking in on_event or process_sync_events"
      pattern: "check_staleness|staleness"
    - from: "claude-tasks/src/state.rs"
      to: "StalenessTracker"
      via: "Tracker stored in SyncState"
      pattern: "staleness|tracker"
---

<objective>
Implement staleness detection to show when a tasklist hasn't received updates.

Purpose: Users want visual indication when Claude hasn't updated tasks recently (DISP-03). This helps identify stale sync or paused Claude sessions.

Output: New staleness.rs module with tracker, header update command for staleness display, integration with sync events.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-robustness-and-features/02-RESEARCH.md
@.planning/phases/02-robustness-and-features/02-CONTEXT.md

# Existing source files (after 02-02)
@claude-tasks/src/lib.rs
@claude-tasks/src/state.rs
@claude-tasks/src/commands.rs
@claude-tasks/src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create staleness tracking module</name>
  <files>claude-tasks/src/staleness.rs</files>
  <action>
Create new `staleness.rs` module:

```rust
//! Staleness tracking for tasklist updates.
//!
//! Tracks time since last update and provides human-readable staleness display.
//! Default threshold: 15 minutes without updates triggers stale state.

use std::time::{Duration, Instant};

/// Tracks staleness of a tasklist.
#[derive(Debug)]
pub struct StalenessTracker {
    /// Time of last recorded update
    last_update: Option<Instant>,
    /// Threshold for staleness (default: 15 minutes)
    threshold: Duration,
}

impl StalenessTracker {
    /// Create a new tracker with the given threshold in minutes.
    pub fn new(threshold_minutes: u64) -> Self {
        Self {
            last_update: None,
            threshold: Duration::from_secs(threshold_minutes * 60),
        }
    }

    /// Record that an update was received.
    pub fn record_update(&mut self) {
        self.last_update = Some(Instant::now());
    }

    /// Check if the tasklist is stale.
    ///
    /// Returns None if not stale (or no updates yet), Some(duration) if stale.
    pub fn check_staleness(&self) -> Option<Duration> {
        self.last_update.and_then(|instant| {
            let elapsed = instant.elapsed();
            if elapsed > self.threshold {
                Some(elapsed)
            } else {
                None
            }
        })
    }

    /// Check if we're currently tracking (have received at least one update).
    pub fn is_tracking(&self) -> bool {
        self.last_update.is_some()
    }

    /// Format staleness duration for display.
    ///
    /// Returns None if not stale, Some("Xm") or Some("XhYm") if stale.
    pub fn format_staleness(&self) -> Option<String> {
        self.check_staleness().map(|elapsed| format_duration(elapsed))
    }

    /// Get time since last update.
    pub fn time_since_update(&self) -> Option<Duration> {
        self.last_update.map(|instant| instant.elapsed())
    }
}

impl Default for StalenessTracker {
    fn default() -> Self {
        Self::new(15) // 15 minutes default
    }
}

/// Format a duration for human display.
///
/// - Less than 60 minutes: "Xm" (e.g., "23m")
/// - 60+ minutes: "XhYm" (e.g., "1h5m")
pub fn format_duration(duration: Duration) -> String {
    let total_minutes = duration.as_secs() / 60;

    if total_minutes < 60 {
        format!("{}m", total_minutes)
    } else {
        let hours = total_minutes / 60;
        let minutes = total_minutes % 60;
        if minutes == 0 {
            format!("{}h", hours)
        } else {
            format!("{}h{}m", hours, minutes)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;

    #[test]
    fn test_new_tracker() {
        let tracker = StalenessTracker::new(15);
        assert!(!tracker.is_tracking());
        assert!(tracker.check_staleness().is_none());
    }

    #[test]
    fn test_record_update() {
        let mut tracker = StalenessTracker::new(15);
        tracker.record_update();
        assert!(tracker.is_tracking());
        // Just updated, shouldn't be stale
        assert!(tracker.check_staleness().is_none());
    }

    #[test]
    fn test_staleness_detection() {
        // Use very short threshold for testing
        let mut tracker = StalenessTracker::new(0); // 0 minutes = immediate staleness
        tracker.record_update();

        // Small sleep to ensure time passes
        thread::sleep(Duration::from_millis(10));

        // Should be stale now
        assert!(tracker.check_staleness().is_some());
    }

    #[test]
    fn test_format_duration_minutes() {
        assert_eq!(format_duration(Duration::from_secs(0)), "0m");
        assert_eq!(format_duration(Duration::from_secs(60)), "1m");
        assert_eq!(format_duration(Duration::from_secs(23 * 60)), "23m");
        assert_eq!(format_duration(Duration::from_secs(59 * 60)), "59m");
    }

    #[test]
    fn test_format_duration_hours() {
        assert_eq!(format_duration(Duration::from_secs(60 * 60)), "1h");
        assert_eq!(format_duration(Duration::from_secs(65 * 60)), "1h5m");
        assert_eq!(format_duration(Duration::from_secs(90 * 60)), "1h30m");
        assert_eq!(format_duration(Duration::from_secs(120 * 60)), "2h");
        assert_eq!(format_duration(Duration::from_secs(125 * 60)), "2h5m");
    }

    #[test]
    fn test_default_threshold() {
        let tracker = StalenessTracker::default();
        assert_eq!(tracker.threshold, Duration::from_secs(15 * 60));
    }
}
```

Add to lib.rs: `pub mod staleness;`
  </action>
  <verify>
cargo check passes.
cargo test staleness passes all staleness tests.
  </verify>
  <done>
staleness.rs exists with StalenessTracker struct, record_update, check_staleness, and format_duration functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add header update command and integrate tracker</name>
  <files>claude-tasks/src/commands.rs, claude-tasks/src/state.rs</files>
  <action>
1. Add header update command to commands.rs:
```rust
/// Create an update command for the header todo with optional staleness indicator.
///
/// Format: "CLAUDE TASKLIST: {name}" or "CLAUDE TASKLIST: {name} \u{23F0} STALE (Xm)"
pub fn update_header_command(
    tasklist_id: &str,
    display_name: Option<&str>,
    staleness: Option<&str>,
) -> FfiCommand {
    let name = display_name.unwrap_or(tasklist_id);
    let content = match staleness {
        Some(duration) => format!("CLAUDE TASKLIST: {} \u{23F0} STALE ({})", name, duration),
        None => format!("CLAUDE TASKLIST: {}", name),
    };

    FfiCommand::UpdateTodo {
        id: RString::from(header_id(tasklist_id)),
        content: ROption::RSome(RString::from(content)),
        state: ROption::RNone,
        priority: ROption::RNone,
        due_date: ROption::RNone,
        description: ROption::RNone,
    }
}
```

2. Update state.rs to include staleness tracker:
   - Add import: `use crate::staleness::StalenessTracker;`
   - Add field to SyncState: `pub staleness_tracker: StalenessTracker,`
   - Update Default impl to initialize tracker (will be replaced with config threshold later)

3. Add test for header update command:
```rust
#[test]
fn test_update_header_command_no_staleness() {
    let cmd = update_header_command("abc-123", Some("MyProject"), None);
    match cmd {
        FfiCommand::UpdateTodo { id, content, .. } => {
            assert_eq!(id.as_str(), "claude-header-abc-123");
            assert!(matches!(content, ROption::RSome(ref s) if s.as_str() == "CLAUDE TASKLIST: MyProject"));
        }
        _ => panic!("Expected UpdateTodo"),
    }
}

#[test]
fn test_update_header_command_with_staleness() {
    let cmd = update_header_command("abc-123", Some("MyProject"), Some("23m"));
    match cmd {
        FfiCommand::UpdateTodo { content, .. } => {
            let content_str = match content {
                ROption::RSome(s) => s.as_str().to_string(),
                _ => panic!("Expected content"),
            };
            assert!(content_str.contains("STALE"));
            assert!(content_str.contains("23m"));
            assert!(content_str.contains("\u{23F0}")); // alarm clock emoji
        }
        _ => panic!("Expected UpdateTodo"),
    }
}
```
  </action>
  <verify>
cargo check passes.
cargo test commands passes new header update tests.
  </verify>
  <done>
update_header_command function exists. SyncState includes StalenessTracker field.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate staleness into sync flow</name>
  <files>claude-tasks/src/lib.rs</files>
  <action>
Update lib.rs to track and check staleness:

1. In on_config_loaded, initialize staleness tracker with config threshold:
   ```rust
   // After loading config
   {
       let mut state = self.state.lock().unwrap();
       state.config = config.clone();
       // Initialize staleness tracker with configured threshold
       state.staleness_tracker = crate::staleness::StalenessTracker::new(
           config.staleness_threshold()
       );
   }
   ```

2. In process_sync_events_local, record updates when events are processed:
   ```rust
   // At start of processing events (after events vec is collected)
   if !events.is_empty() {
       let mut state = self.state.lock().unwrap();
       state.staleness_tracker.record_update();
   }
   ```

3. In on_event (OnLoad handler), check staleness and update header if needed:
   ```rust
   fn on_event(&self, event: FfiEvent) -> RResult<FfiHookResponse, RString> {
       if let FfiEvent::OnLoad { .. } = event {
           let mut commands = self.process_sync_events_local();

           // Check staleness and update header if stale
           let staleness_info = {
               let state = self.state.lock().unwrap();
               if let Some(ref tasklist_path) = state.selected_tasklist {
                   let tasklist_id = tasklist_path
                       .file_name()
                       .and_then(|n| n.to_str())
                       .unwrap_or("unknown")
                       .to_string();
                   let alias = state.config.get_alias(&tasklist_id).map(|s| s.to_string());
                   let staleness = state.staleness_tracker.format_staleness();
                   Some((tasklist_id, alias, staleness))
               } else {
                   None
               }
           };

           // Add header update if stale (or if transitioning from stale to fresh)
           if let Some((tasklist_id, alias, staleness)) = staleness_info {
               if staleness.is_some() || !commands.is_empty() {
                   // Update header with or without staleness indicator
                   commands.push(crate::commands::update_header_command(
                       &tasklist_id,
                       alias.as_deref(),
                       staleness.as_deref(),
                   ));
               }
           }

           if !commands.is_empty() {
               eprintln!(
                   "claude-tasks: on_event returning {} commands",
                   commands.len()
               );
           }

           return RResult::ROk(FfiHookResponse {
               commands: commands.into_iter().collect(),
           });
       }

       RResult::ROk(FfiHookResponse::default())
   }
   ```
  </action>
  <verify>
cargo check passes.
cargo test passes all existing tests.
  </verify>
  <done>
Staleness tracker initialized with config threshold. Updates recorded when events processed. Header updated with staleness indicator when stale.
  </done>
</task>

</tasks>

<verification>
1. `cd claude-tasks && cargo test` - All tests pass including staleness tests
2. `cargo clippy -- -D warnings` - No warnings
3. `cargo build --release` - Builds successfully
4. Manual verification: Set low staleness threshold, observe header update after threshold
</verification>

<success_criteria>
- StalenessTracker struct tracks last update time and checks against threshold
- format_duration returns human-readable format ("23m", "1h5m")
- update_header_command generates header with staleness indicator
- Header shows "\u{23F0} STALE (Xm)" when no updates for threshold duration
- Staleness clears when updates resume (header updated without staleness)
- Threshold configurable via config.staleness_threshold_minutes
</success_criteria>

<output>
After completion, create `.planning/phases/02-robustness-and-features/02-04-SUMMARY.md`
</output>
