---
phase: 02-robustness-and-features
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - claude-tasks/src/hierarchy.rs
  - claude-tasks/src/commands.rs
  - claude-tasks/src/sync.rs
  - claude-tasks/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Single blocker task appears as parent of blocked task (indented underneath)"
    - "Multiple blockers result in root-level task with annotation"
    - "Circular dependencies are detected and shown at root with warning"
    - "Max nesting depth of 3 levels is enforced"
  artifacts:
    - path: "claude-tasks/src/hierarchy.rs"
      provides: "TaskHierarchy struct with build_hierarchy and detect_cycles functions"
      min_lines: 80
    - path: "claude-tasks/src/commands.rs"
      provides: "create_todo_commands with parent_id based on hierarchy"
      contains: "parent_id"
  key_links:
    - from: "claude-tasks/src/sync.rs"
      to: "hierarchy::build_hierarchy"
      via: "Hierarchy building before command generation"
      pattern: "build_hierarchy"
    - from: "claude-tasks/src/commands.rs"
      to: "TaskHierarchy"
      via: "Parent-child relationships in CreateTodo"
      pattern: "parent_id|hierarchy"
---

<objective>
Implement dependency hierarchy visualization for Claude tasks in totui.

Purpose: Users want to see task dependencies as parent-child relationships (SYNC-05). Single blocker = parent, multiple blockers = annotation, cycles = warning.

Output: New hierarchy.rs module with cycle detection and depth-limited tree building, updated command generation to use parent_id based on hierarchy.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-robustness-and-features/02-RESEARCH.md
@.planning/phases/02-robustness-and-features/02-CONTEXT.md

# Existing source files
@claude-tasks/src/claude_task.rs
@claude-tasks/src/commands.rs
@claude-tasks/src/sync.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hierarchy module with cycle detection</name>
  <files>claude-tasks/src/hierarchy.rs</files>
  <action>
Create new `hierarchy.rs` module:

```rust
//! Dependency hierarchy building for Claude tasks.
//!
//! Builds parent-child relationships from blocked_by arrays.
//! - Single blocker = parent
//! - Multiple blockers = annotation
//! - Cycles = warning at root level
//! - Max depth = 3 levels

use crate::claude_task::ClaudeTask;
use std::collections::{HashMap, HashSet};

/// Maximum nesting depth for hierarchy.
const MAX_DEPTH: usize = 3;

/// Computed hierarchy for a set of tasks.
#[derive(Debug, Default)]
pub struct TaskHierarchy {
    /// task_id -> parent_task_id (single blocker case)
    pub parent_map: HashMap<String, String>,
    /// task_id -> annotation text (multiple blockers or deep chain)
    pub annotations: HashMap<String, String>,
    /// Tasks involved in circular dependencies
    pub cyclic_tasks: HashSet<String>,
}

impl TaskHierarchy {
    /// Get parent task ID if this task has exactly one blocker within depth limit.
    pub fn get_parent(&self, task_id: &str) -> Option<&str> {
        self.parent_map.get(task_id).map(|s| s.as_str())
    }

    /// Get annotation for this task (multiple blockers or flattened chain).
    pub fn get_annotation(&self, task_id: &str) -> Option<&str> {
        self.annotations.get(task_id).map(|s| s.as_str())
    }

    /// Check if task is in a cycle.
    pub fn is_cyclic(&self, task_id: &str) -> bool {
        self.cyclic_tasks.contains(task_id)
    }
}

/// Build hierarchy from a set of tasks.
///
/// Rules per CONTEXT.md:
/// - Single blocker within depth limit: task becomes child of blocker
/// - Multiple blockers: task at root with "Blocked by: A, B" annotation
/// - Circular dependency: task at root with cycle warning
/// - Depth > MAX_DEPTH: flatten to root with chain annotation
pub fn build_hierarchy(tasks: &[ClaudeTask]) -> TaskHierarchy {
    let mut hierarchy = TaskHierarchy::default();

    // Build task lookup map
    let task_map: HashMap<&str, &ClaudeTask> = tasks.iter()
        .map(|t| (t.id.as_str(), t))
        .collect();

    // First pass: detect cycles
    let cyclic = detect_cycles(tasks);
    hierarchy.cyclic_tasks = cyclic;

    // Second pass: build hierarchy
    for task in tasks {
        // Skip tasks in cycles - they go to root with warning
        if hierarchy.cyclic_tasks.contains(&task.id) {
            hierarchy.annotations.insert(
                task.id.clone(),
                "\u{26A0} Circular dependency".to_string(),
            );
            continue;
        }

        match task.blocked_by.len() {
            0 => {
                // No blockers - root level (no parent, no annotation)
            }
            1 => {
                // Single blocker - potential parent
                let parent_id = &task.blocked_by[0];

                // Check if parent exists and compute depth
                if task_map.contains_key(parent_id.as_str()) {
                    let depth = calculate_depth(parent_id, &hierarchy.parent_map, &task_map);

                    if depth < MAX_DEPTH {
                        // Within depth limit - set parent
                        hierarchy.parent_map.insert(task.id.clone(), parent_id.clone());
                    } else {
                        // Too deep - flatten with chain annotation
                        let chain = build_chain_annotation(parent_id, &hierarchy.parent_map, &task_map);
                        hierarchy.annotations.insert(task.id.clone(), chain);
                    }
                }
                // If parent doesn't exist, task stays at root (orphan blocker)
            }
            _ => {
                // Multiple blockers - root level with annotation
                let names: Vec<&str> = task.blocked_by.iter()
                    .filter_map(|id| task_map.get(id.as_str()).map(|t| t.subject.as_str()))
                    .collect();

                if !names.is_empty() {
                    let annotation = format!("\u{26D4} Blocked by: {}", names.join(", "));
                    hierarchy.annotations.insert(task.id.clone(), annotation);
                }
            }
        }
    }

    hierarchy
}

/// Detect circular dependencies using DFS with coloring.
///
/// Returns set of task IDs involved in cycles.
fn detect_cycles(tasks: &[ClaudeTask]) -> HashSet<String> {
    let mut cyclic = HashSet::new();
    let mut visited = HashSet::new();
    let mut in_stack = HashSet::new();

    // Build adjacency list (task -> tasks it's blocked by)
    let adj: HashMap<&str, Vec<&str>> = tasks.iter()
        .map(|t| (t.id.as_str(), t.blocked_by.iter().map(|s| s.as_str()).collect()))
        .collect();

    for task in tasks {
        if !visited.contains(task.id.as_str()) {
            dfs_cycle(&task.id, &adj, &mut visited, &mut in_stack, &mut cyclic);
        }
    }

    cyclic
}

/// DFS to find cycles. Marks all nodes in cycle.
fn dfs_cycle<'a>(
    node: &'a str,
    adj: &HashMap<&'a str, Vec<&'a str>>,
    visited: &mut HashSet<&'a str>,
    in_stack: &mut HashSet<&'a str>,
    cyclic: &mut HashSet<String>,
) {
    visited.insert(node);
    in_stack.insert(node);

    if let Some(neighbors) = adj.get(node) {
        for &neighbor in neighbors {
            if !visited.contains(neighbor) {
                dfs_cycle(neighbor, adj, visited, in_stack, cyclic);
            } else if in_stack.contains(neighbor) {
                // Cycle detected - mark both nodes
                cyclic.insert(node.to_string());
                cyclic.insert(neighbor.to_string());
            }
        }
    }

    in_stack.remove(node);
}

/// Calculate depth of a task in the hierarchy.
fn calculate_depth(
    task_id: &str,
    parent_map: &HashMap<String, String>,
    task_map: &HashMap<&str, &ClaudeTask>,
) -> usize {
    let mut depth = 0;
    let mut current = task_id;

    while let Some(parent) = parent_map.get(current) {
        depth += 1;
        if depth >= MAX_DEPTH || !task_map.contains_key(parent.as_str()) {
            break;
        }
        current = parent;
    }

    depth
}

/// Build chain annotation for deep hierarchies.
fn build_chain_annotation(
    parent_id: &str,
    parent_map: &HashMap<String, String>,
    task_map: &HashMap<&str, &ClaudeTask>,
) -> String {
    let mut chain = Vec::new();
    let mut current = parent_id;

    // Walk up the chain collecting names
    loop {
        if let Some(task) = task_map.get(current) {
            chain.push(task.subject.as_str());
        }
        if let Some(parent) = parent_map.get(current) {
            current = parent;
        } else {
            break;
        }
        if chain.len() >= MAX_DEPTH + 1 {
            break;
        }
    }

    chain.reverse();
    format!("\u{26D4} Blocked by: {}", chain.join(" \u{2192} "))
}
```

Add to lib.rs: `pub mod hierarchy;`
  </action>
  <verify>
cargo check passes.
cargo test passes (no breaking changes to existing code).
  </verify>
  <done>
hierarchy.rs exists with TaskHierarchy struct, build_hierarchy function, detect_cycles using DFS, and depth-limited parent assignment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update commands to use hierarchy for parent_id</name>
  <files>claude-tasks/src/commands.rs</files>
  <action>
Update commands.rs to support hierarchy-based parent assignment:

1. Add new function for creating todo with hierarchy context:
```rust
/// Create commands for a new todo with hierarchy context.
///
/// Uses hierarchy to determine:
/// - parent_id: if task has single blocker within depth, parent is blocker's todo
/// - annotation: prepended to content if multiple blockers or deep chain
pub fn create_todo_commands_with_hierarchy(
    task: &ClaudeTask,
    tasklist_id: &str,
    header_id: &str,
    hierarchy: &crate::hierarchy::TaskHierarchy,
) -> Vec<FfiCommand> {
    let temp_id = format!("claude-{}-{}", tasklist_id, task.id);

    // Determine parent_id
    let parent_id = if let Some(parent_task_id) = hierarchy.get_parent(&task.id) {
        // Parent is another task's todo
        ROption::RSome(RString::from(task_todo_id(tasklist_id, parent_task_id)))
    } else {
        // No hierarchy parent - use header
        ROption::RSome(RString::from(header_id))
    };

    // Determine indent level based on hierarchy depth
    let indent_level = if hierarchy.get_parent(&task.id).is_some() { 2 } else { 1 };

    // Format content with annotation if needed
    let mut content = format_task_content(task);
    if let Some(annotation) = hierarchy.get_annotation(&task.id) {
        // Annotation replaces blocked indicator - don't double up
        if !task.blocked_by.is_empty() && !content.starts_with('\u{26D4}') {
            content = format!("{} - {}", annotation, task.subject);
        } else if hierarchy.is_cyclic(&task.id) {
            content = format!("{} {}", annotation, task.subject);
        }
    }

    let create_cmd = FfiCommand::CreateTodo {
        content: RString::from(content),
        parent_id,
        temp_id: ROption::RSome(RString::from(temp_id.clone())),
        state: map_status_to_state(&task.status),
        priority: ROption::RNone,
        indent_level,
    };

    // Build metadata JSON
    let metadata = build_metadata_json(tasklist_id, &task.id, &task.blocked_by);

    let metadata_cmd = FfiCommand::SetTodoMetadata {
        todo_id: RString::from(temp_id),
        data: RString::from(metadata),
        merge: false,
    };

    vec![create_cmd, metadata_cmd]
}
```

2. Keep existing create_todo_commands for backward compatibility (non-hierarchy sync paths).
  </action>
  <verify>
cargo check passes with new function.
Existing tests still pass.
  </verify>
  <done>
create_todo_commands_with_hierarchy function exists that uses TaskHierarchy to set parent_id and annotations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate hierarchy into sync and add tests</name>
  <files>claude-tasks/src/sync.rs, claude-tasks/src/hierarchy.rs</files>
  <action>
1. Update sync.rs process_initial_scan_local to use hierarchy:
   - Add import: `use crate::hierarchy::build_hierarchy;`
   - Add import: `use crate::commands::create_todo_commands_with_hierarchy;`
   - After reading tasks, build hierarchy:
     ```rust
     let hierarchy = build_hierarchy(&claude_tasks);
     ```
   - Replace create_todo_commands with create_todo_commands_with_hierarchy:
     ```rust
     for task in &claude_tasks {
         task_ids.push(task.id.clone());
         commands.extend(create_todo_commands_with_hierarchy(
             task, tasklist_id, &hdr_id, &hierarchy
         ));
     }
     ```

2. Add comprehensive tests to hierarchy.rs:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn make_task(id: &str, subject: &str, blocked_by: Vec<&str>) -> ClaudeTask {
        ClaudeTask {
            id: id.to_string(),
            subject: subject.to_string(),
            description: String::new(),
            active_form: String::new(),
            status: "pending".to_string(),
            blocks: vec![],
            blocked_by: blocked_by.into_iter().map(String::from).collect(),
        }
    }

    #[test]
    fn test_no_dependencies() {
        let tasks = vec![
            make_task("1", "Task A", vec![]),
            make_task("2", "Task B", vec![]),
        ];
        let hierarchy = build_hierarchy(&tasks);

        assert!(hierarchy.get_parent("1").is_none());
        assert!(hierarchy.get_parent("2").is_none());
        assert!(hierarchy.annotations.is_empty());
    }

    #[test]
    fn test_single_blocker_creates_parent() {
        let tasks = vec![
            make_task("1", "Task A", vec![]),
            make_task("2", "Task B", vec!["1"]),
        ];
        let hierarchy = build_hierarchy(&tasks);

        assert!(hierarchy.get_parent("1").is_none());
        assert_eq!(hierarchy.get_parent("2"), Some("1"));
    }

    #[test]
    fn test_multiple_blockers_creates_annotation() {
        let tasks = vec![
            make_task("1", "Task A", vec![]),
            make_task("2", "Task B", vec![]),
            make_task("3", "Task C", vec!["1", "2"]),
        ];
        let hierarchy = build_hierarchy(&tasks);

        assert!(hierarchy.get_parent("3").is_none());
        let annotation = hierarchy.get_annotation("3").unwrap();
        assert!(annotation.contains("Blocked by"));
        assert!(annotation.contains("Task A"));
        assert!(annotation.contains("Task B"));
    }

    #[test]
    fn test_cycle_detection() {
        let tasks = vec![
            make_task("1", "Task A", vec!["2"]),
            make_task("2", "Task B", vec!["1"]),
        ];
        let hierarchy = build_hierarchy(&tasks);

        assert!(hierarchy.is_cyclic("1"));
        assert!(hierarchy.is_cyclic("2"));
        assert!(hierarchy.get_annotation("1").unwrap().contains("Circular"));
    }

    #[test]
    fn test_depth_limit() {
        // Create chain: 4 -> 3 -> 2 -> 1
        let tasks = vec![
            make_task("1", "Level 0", vec![]),
            make_task("2", "Level 1", vec!["1"]),
            make_task("3", "Level 2", vec!["2"]),
            make_task("4", "Level 3", vec!["3"]), // Should be flattened
        ];
        let hierarchy = build_hierarchy(&tasks);

        // First 3 levels should have parents
        assert!(hierarchy.get_parent("1").is_none()); // root
        assert_eq!(hierarchy.get_parent("2"), Some("1"));
        assert_eq!(hierarchy.get_parent("3"), Some("2"));
        // Level 4 should be flattened with annotation
        assert!(hierarchy.get_parent("4").is_none());
        assert!(hierarchy.get_annotation("4").is_some());
    }

    #[test]
    fn test_missing_blocker_ignored() {
        let tasks = vec![
            make_task("1", "Task A", vec!["999"]), // blocker doesn't exist
        ];
        let hierarchy = build_hierarchy(&tasks);

        // Should not crash, task stays at root
        assert!(hierarchy.get_parent("1").is_none());
    }
}
```
  </action>
  <verify>
cargo test passes all hierarchy tests.
cargo test passes all sync tests.
  </verify>
  <done>
Hierarchy is built in initial_scan and used for parent_id assignment. Tests verify single blocker, multiple blockers, cycles, and depth limits.
  </done>
</task>

</tasks>

<verification>
1. `cd claude-tasks && cargo test` - All tests pass including hierarchy tests
2. `cargo clippy -- -D warnings` - No warnings
3. `cargo build --release` - Builds successfully
4. Manual verification: Create test tasks with dependencies and verify parent-child relationships
</verification>

<success_criteria>
- hierarchy.rs exists with build_hierarchy, detect_cycles, and TaskHierarchy struct
- Single blocker within depth limit creates parent-child relationship
- Multiple blockers result in root-level task with "Blocked by: A, B" annotation
- Circular dependencies detected and shown at root with warning emoji
- Max depth of 3 enforced; deeper chains flattened with chain annotation
- All tests pass including cycle detection and depth limiting
</success_criteria>

<output>
After completion, create `.planning/phases/02-robustness-and-features/02-03-SUMMARY.md`
</output>
