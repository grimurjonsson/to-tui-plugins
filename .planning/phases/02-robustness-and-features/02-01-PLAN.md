---
phase: 02-robustness-and-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - claude-tasks/src/errors.rs
  - claude-tasks/src/watcher.rs
  - claude-tasks/src/lib.rs
  - claude-tasks/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Plugin displays clear error message when inotify watch limit is reached"
    - "Plugin displays clear error message when macOS file descriptor limit is reached"
    - "Watcher thread stops cleanly when plugin unloads (no orphaned threads)"
    - "Plugin continues to function after transient file system errors"
  artifacts:
    - path: "claude-tasks/src/errors.rs"
      provides: "PluginError enum with Display impl for user-facing messages"
      min_lines: 30
    - path: "claude-tasks/src/watcher.rs"
      provides: "WatcherHandle with shutdown flag and Drop impl"
      contains: "impl Drop for WatcherHandle"
  key_links:
    - from: "claude-tasks/src/watcher.rs"
      to: "notify::ErrorKind"
      via: "Error kind matching in start_watcher"
      pattern: "ErrorKind::MaxFilesWatch|ErrorKind::Io"
    - from: "claude-tasks/src/lib.rs"
      to: "WatcherHandle::shutdown"
      via: "Drop trait or explicit cleanup"
      pattern: "shutdown|Drop"
---

<objective>
Add platform-aware error handling and graceful watcher cleanup to make the plugin production-ready.

Purpose: Users need actionable error messages when platform limits are reached (WATCH-04, WATCH-05, DISP-04), and the plugin must clean up watcher threads on unload (PLUG-04).

Output: New errors.rs module with PluginError enum, updated watcher.rs with shutdown signal and Drop impl, platform-specific error detection.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-robustness-and-features/02-RESEARCH.md

# Existing source files
@claude-tasks/src/watcher.rs
@claude-tasks/src/lib.rs
@claude-tasks/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create errors module with platform-aware error types</name>
  <files>claude-tasks/src/errors.rs</files>
  <action>
Create new `errors.rs` module with:

1. `PluginError` enum with variants:
   - `WatchLimitReached(String)` - Platform-specific limit message
   - `WatcherFailed(String)` - Generic watcher failure
   - `DirectoryNotFound` - Tasks directory missing
   - `ConfigParseError(String)` - Invalid config file

2. `impl std::fmt::Display` for `PluginError`:
   - Keep messages brief and actionable per CONTEXT.md decisions
   - WatchLimitReached: pass through the message (it's already platform-specific)
   - WatcherFailed: "Watch failed: {msg}"
   - DirectoryNotFound: "Tasks directory not found"
   - ConfigParseError: "Invalid config: {path}"

3. `impl std::error::Error` for `PluginError`

4. `fn handle_notify_error(error: &notify::Error) -> PluginError`:
   - Match on `error.kind`:
   - `ErrorKind::MaxFilesWatch` -> "inotify watch limit reached"
   - `ErrorKind::Io(io_err)` with raw_os_error() 28 (ENOSPC) -> "inotify watch limit reached"
   - `ErrorKind::Io(io_err)` with raw_os_error() 24 (EMFILE) -> "File descriptor limit reached"
   - `ErrorKind::PathNotFound` -> DirectoryNotFound
   - Other -> WatcherFailed with error message

5. Add module to lib.rs: `pub mod errors;`
  </action>
  <verify>
cargo check in claude-tasks directory passes.
Run: `cargo check 2>&1 | grep -E "(error|warning)" | head -5` should show no errors related to errors.rs.
  </verify>
  <done>
errors.rs exists with PluginError enum, Display impl, and handle_notify_error function that maps notify errors to user-facing messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add graceful shutdown to WatcherHandle</name>
  <files>claude-tasks/src/watcher.rs</files>
  <action>
Update WatcherHandle to support graceful shutdown:

1. Add imports at top:
   ```rust
   use std::sync::atomic::{AtomicBool, Ordering};
   use std::sync::Arc;
   ```

2. Update WatcherHandle struct:
   ```rust
   pub struct WatcherHandle {
       thread_handle: Option<JoinHandle<()>>,
       shutdown_flag: Arc<AtomicBool>,
   }
   ```

3. Update WatcherHandle::new() to accept shutdown_flag:
   ```rust
   fn new(handle: JoinHandle<()>, shutdown_flag: Arc<AtomicBool>) -> Self
   ```

4. Add shutdown method:
   ```rust
   pub fn shutdown(&mut self) {
       // Signal thread to stop
       self.shutdown_flag.store(true, Ordering::SeqCst);

       // Take ownership and join
       if let Some(handle) = self.thread_handle.take() {
           handle.thread().unpark();
           let _ = handle.join();
       }
   }
   ```

5. Implement Drop trait:
   ```rust
   impl Drop for WatcherHandle {
       fn drop(&mut self) {
           self.shutdown();
       }
   }
   ```

6. Update start_watcher function:
   - Create `shutdown_flag = Arc::new(AtomicBool::new(false))`
   - Clone for thread: `let shutdown_for_thread = shutdown_flag.clone()`
   - In thread loop, change from `loop { thread::park(); }` to:
     ```rust
     loop {
         if shutdown_for_thread.load(Ordering::SeqCst) {
             break;
         }
         thread::park_timeout(Duration::from_millis(100));
     }
     ```
   - Return `WatcherHandle::new(handle, shutdown_flag)`

7. Update start_watcher to use handle_notify_error for better error messages:
   - Import `crate::errors::handle_notify_error`
   - When debouncer.watch() fails, convert error with handle_notify_error
   - Return the user-facing error message
  </action>
  <verify>
cargo test in claude-tasks directory passes all watcher tests.
cargo check shows no warnings about unused imports or dead code.
  </verify>
  <done>
WatcherHandle has shutdown_flag, shutdown() method, and Drop impl. Thread loop checks shutdown flag every 100ms and exits cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for error handling and cleanup</name>
  <files>claude-tasks/src/errors.rs, claude-tasks/src/watcher.rs</files>
  <action>
Add tests to verify error handling and cleanup:

1. In errors.rs, add tests module:
   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;
       use notify::{Error, ErrorKind};
       use std::io;

       #[test]
       fn test_max_files_watch_error() {
           let error = Error::new(ErrorKind::MaxFilesWatch);
           let plugin_error = handle_notify_error(&error);
           let msg = plugin_error.to_string();
           assert!(msg.contains("inotify") || msg.contains("watch limit"));
       }

       #[test]
       fn test_path_not_found_error() {
           let error = Error::new(ErrorKind::PathNotFound);
           let plugin_error = handle_notify_error(&error);
           assert!(matches!(plugin_error, PluginError::DirectoryNotFound));
       }

       #[test]
       fn test_io_error_emfile() {
           let io_err = io::Error::from_raw_os_error(24);
           let error = Error::new(ErrorKind::Io(io_err.into()));
           let plugin_error = handle_notify_error(&error);
           assert!(plugin_error.to_string().contains("descriptor"));
       }

       #[test]
       fn test_display_formatting() {
           let err = PluginError::WatcherFailed("test".into());
           assert_eq!(err.to_string(), "Watch failed: test");

           let err = PluginError::DirectoryNotFound;
           assert_eq!(err.to_string(), "Tasks directory not found");
       }
   }
   ```

2. In watcher.rs, add test for shutdown:
   ```rust
   #[test]
   fn test_watcher_handle_shutdown() {
       use std::sync::atomic::{AtomicBool, Ordering};
       use std::sync::Arc;

       let flag = Arc::new(AtomicBool::new(false));
       let flag_clone = flag.clone();

       let handle = thread::spawn(move || {
           while !flag_clone.load(Ordering::SeqCst) {
               thread::park_timeout(Duration::from_millis(10));
           }
       });

       let mut watcher = WatcherHandle {
           thread_handle: Some(handle),
           shutdown_flag: flag,
       };

       // Shutdown should complete without hanging
       watcher.shutdown();
       assert!(watcher.thread_handle.is_none());
   }
   ```
  </action>
  <verify>
cargo test in claude-tasks passes all tests including new error and shutdown tests.
Run: `cargo test 2>&1 | grep -E "(test result|passed|failed)"` should show all tests passed.
  </verify>
  <done>
Error handling tests verify platform error mapping. Shutdown test verifies thread cleanup completes without hanging.
  </done>
</task>

</tasks>

<verification>
1. `cd claude-tasks && cargo test` - All tests pass (including new error and shutdown tests)
2. `cargo clippy -- -D warnings` - No warnings
3. `cargo build --release` - Builds successfully
4. Manual verification: Drop impl ensures WatcherHandle cleanup on plugin unload
</verification>

<success_criteria>
- PluginError enum exists with Display impl providing actionable messages
- handle_notify_error correctly maps MaxFilesWatch, EMFILE (24), ENOSPC (28) to appropriate messages
- WatcherHandle has shutdown_flag checked every 100ms in thread loop
- Drop impl calls shutdown() for guaranteed cleanup
- All tests pass including new error handling and shutdown tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-robustness-and-features/02-01-SUMMARY.md`
</output>
