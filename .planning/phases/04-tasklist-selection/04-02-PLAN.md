---
phase: 04-tasklist-selection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - claude-tasks/src/lib.rs
  - claude-tasks/src/config.rs
autonomous: true
gap_closure: false

must_haves:
  truths:
    - "config_schema returns a Select field with tasklist as the name"
    - "Select options include all discovered tasklists with display info"
    - "on_config_loaded reads selected tasklist from config parameter"
    - "User can override selection via config file (tasklist = UUID)"
  artifacts:
    - path: "claude-tasks/src/lib.rs"
      provides: "config_schema with FfiConfigType::Select"
      contains: "FfiConfigType::Select"
    - path: "claude-tasks/src/config.rs"
      provides: "generate_tasklist_options function"
      contains: "generate_tasklist_options"
  key_links:
    - from: "config_schema"
      to: "discovery::discover_tasklists"
      via: "generate options from discovered tasklists"
      pattern: "discover_tasklists"
    - from: "on_config_loaded"
      to: "config.get(tasklist)"
      via: "read user selection from config"
      pattern: "tasklist"
---

<objective>
Wire config_schema to return Select field with discovered tasklists.

Purpose: When user adds the plugin, they see a dropdown of available tasklists instead of an empty config.
Output: User can select which Claude tasklist to watch via the plugin config UI.
</objective>

<context>
The totui-plugin-interface v0.2.0 now has:
- FfiConfigType::Select = 4
- FfiConfigField.options: RVec<RString> for Select options

Current state:
- config_schema() returns FfiConfigSchema::empty()
- on_config_loaded() auto-selects first tasklist
- discovery::discover_tasklists() returns Vec<TasklistInfo>
- format_tasklist_display() formats UUID with optional alias

Needed:
1. config_schema() returns schema with Select field for tasklist
2. Options populated from discover_tasklists() with display formatting
3. on_config_loaded() reads selected value from config map
4. Fallback: if config has tasklist=UUID, use that; else auto-select first
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generate_tasklist_options function to config.rs</name>
  <files>claude-tasks/src/config.rs</files>
  <action>
    Add a function that generates Select options from discovered tasklists.

    ```rust
    use crate::discovery::{discover_tasklists, TasklistInfo};
    use std::time::UNIX_EPOCH;

    /// Generate Select options for tasklist picker.
    ///
    /// Format: "Alias (uuid...) - N tasks, updated X ago" or "uuid - N tasks, updated X ago"
    /// Returns (display_string, uuid) pairs.
    pub fn generate_tasklist_options(config: &PluginConfig) -> Vec<(String, String)> {
        let tasklists = discover_tasklists();

        tasklists.into_iter().map(|t| {
            let display = format_tasklist_option(&t, config);
            (display, t.id)
        }).collect()
    }

    /// Format a single tasklist for display in Select options.
    fn format_tasklist_option(tasklist: &TasklistInfo, config: &PluginConfig) -> String {
        let name_part = match config.get_alias(&tasklist.id) {
            Some(alias) => {
                let short_uuid = &tasklist.id[..8.min(tasklist.id.len())];
                format!("{} ({}...)", alias, short_uuid)
            }
            None => tasklist.id.clone(),
        };

        let age = format_age(tasklist.last_modified);
        format!("{} - {} tasks, {}", name_part, tasklist.task_count, age)
    }

    /// Format time since last modified.
    fn format_age(time: std::time::SystemTime) -> String {
        let duration = time.elapsed().unwrap_or_default();
        let secs = duration.as_secs();

        if secs < 60 {
            "just now".to_string()
        } else if secs < 3600 {
            format!("{}m ago", secs / 60)
        } else if secs < 86400 {
            format!("{}h ago", secs / 3600)
        } else {
            format!("{}d ago", secs / 86400)
        }
    }
    ```

    Also export `generate_tasklist_options` from config.rs.
  </action>
  <verify>
    cargo build -p claude-tasks
    cargo test -p claude-tasks config::tests
  </verify>
  <done>
    generate_tasklist_options function creates formatted options from discovered tasklists
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement config_schema with Select field</name>
  <files>claude-tasks/src/lib.rs</files>
  <action>
    Update config_schema() to return a schema with a "tasklist" Select field.

    First, add needed imports:
    ```rust
    use totui_plugin_interface::{
        FfiCommand, FfiConfigField, FfiConfigSchema, FfiConfigType, FfiConfigValue,
        FfiEvent, FfiEventType, FfiHookResponse, FfiTodoItem, HostApi_TO, Plugin,
        PluginModule, PluginModule_Ref, Plugin_TO,
    };
    use config::{format_tasklist_display, generate_tasklist_options, load_config};
    ```

    Then replace config_schema implementation:
    ```rust
    fn config_schema(&self) -> FfiConfigSchema {
        // Load config to resolve aliases for display
        let plugin_config = load_config();

        // Generate options from discovered tasklists
        let options = generate_tasklist_options(&plugin_config);

        // Convert to RVec<RString> - use UUID as the value, display string shown to user
        // Format: "display_string|uuid" so totui can parse both
        let option_strings: RVec<RString> = options
            .iter()
            .map(|(display, uuid)| RString::from(format!("{}|{}", display, uuid)))
            .collect();

        // Create the tasklist field
        let tasklist_field = FfiConfigField {
            name: RString::from("tasklist"),
            field_type: FfiConfigType::Select,
            required: false,  // Will auto-select first if not specified
            default: ROption::RNone,
            description: ROption::RSome(RString::from("Select which Claude tasklist to sync")),
            options: option_strings,
        };

        FfiConfigSchema {
            fields: vec![tasklist_field].into_iter().collect(),
            config_required: false,
        }
    }
    ```

    Note: The options format "display|uuid" allows totui to show the display string while storing the uuid as the value.
  </action>
  <verify>
    cargo build -p claude-tasks
    cargo clippy -p claude-tasks -- -D warnings
  </verify>
  <done>
    config_schema returns Select field with discovered tasklist options
  </done>
</task>

<task type="auto">
  <name>Task 3: Update on_config_loaded to read selected tasklist</name>
  <files>claude-tasks/src/lib.rs</files>
  <action>
    Update on_config_loaded to read the "tasklist" value from the config map.

    Change the on_config_loaded function to:
    1. Check if config contains "tasklist" key
    2. If yes, find that tasklist in discovered list and use it
    3. If no or not found, fall back to auto-select first

    ```rust
    fn on_config_loaded(&self, config: RHashMap<RString, FfiConfigValue>) {
        // Load plugin configuration (global + local merged)
        let plugin_config = load_config();

        // Discover available tasklists
        let tasklists = discovery::discover_tasklists();

        if tasklists.is_empty() {
            eprintln!("claude-tasks: No tasklists found - showing setup guidance");
            let mut state = self.state.lock().unwrap();
            state.pending_commands = create_no_tasklist_guidance();
            state.set_guidance(GuidanceState::NoTasklists);
            return;
        }

        // Check if user selected a specific tasklist
        let selected = if let Some(FfiConfigValue::String(uuid)) = config.get(&RString::from("tasklist")) {
            let uuid_str = uuid.as_str();
            // Find tasklist with matching UUID
            tasklists.iter().find(|t| t.id == uuid_str).cloned()
        } else {
            None
        };

        // Fall back to first tasklist if not specified or not found
        let selected = selected.unwrap_or_else(|| tasklists[0].clone());

        let display_name = format_tasklist_display(&selected.id, &plugin_config);
        eprintln!(
            "claude-tasks: Watching tasklist: {} ({} tasks)",
            display_name,
            selected.task_count
        );

        // Rest of initialization unchanged...
        // Store selected tasklist path and config in state
        {
            let mut state = self.state.lock().unwrap();
            state.selected_tasklist = Some(selected.path.clone());
            state.staleness_tracker =
                staleness::StalenessTracker::new(plugin_config.staleness_threshold());
            state.config = plugin_config;
        }

        // ... continue with channel setup and watcher initialization
    }
    ```

    The key change: read `config.get("tasklist")` and find matching tasklist by UUID.
  </action>
  <verify>
    cargo build --release -p claude-tasks
    cargo test -p claude-tasks
    cargo clippy -p claude-tasks -- -D warnings
  </verify>
  <done>
    on_config_loaded reads user-selected tasklist from config, falls back to auto-select
  </done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for tasklist option generation</name>
  <files>claude-tasks/src/config.rs</files>
  <action>
    Add tests for the new functions in config.rs:

    ```rust
    #[test]
    fn test_format_age_just_now() {
        use std::time::SystemTime;
        let recent = SystemTime::now();
        let age = format_age(recent);
        assert_eq!(age, "just now");
    }

    #[test]
    fn test_format_age_minutes() {
        use std::time::{SystemTime, Duration};
        let past = SystemTime::now() - Duration::from_secs(300); // 5 minutes
        let age = format_age(past);
        assert_eq!(age, "5m ago");
    }

    #[test]
    fn test_format_age_hours() {
        use std::time::{SystemTime, Duration};
        let past = SystemTime::now() - Duration::from_secs(7200); // 2 hours
        let age = format_age(past);
        assert_eq!(age, "2h ago");
    }

    #[test]
    fn test_format_age_days() {
        use std::time::{SystemTime, Duration};
        let past = SystemTime::now() - Duration::from_secs(172800); // 2 days
        let age = format_age(past);
        assert_eq!(age, "2d ago");
    }
    ```
  </action>
  <verify>
    cargo test -p claude-tasks config::tests -- --nocapture
  </verify>
  <done>
    Unit tests verify age formatting functions
  </done>
</task>

</tasks>

<verification>
1. cargo build --release -p claude-tasks passes
2. cargo test -p claude-tasks passes (all tests including new ones)
3. cargo clippy -p claude-tasks -- -D warnings passes
4. config_schema() returns FfiConfigSchema with Select field
5. on_config_loaded reads "tasklist" from config map
</verification>

<success_criteria>
- config_schema returns a Select field named "tasklist"
- Select options populated from discover_tasklists() with formatted display
- on_config_loaded reads user selection from config parameter
- Falls back to auto-select first if no selection in config
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-tasklist-selection/04-02-SUMMARY.md`
</output>
