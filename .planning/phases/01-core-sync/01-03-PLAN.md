---
phase: 01-core-sync
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - claude-tasks/src/lib.rs
  - claude-tasks/src/sync.rs
  - claude-tasks/src/commands.rs
autonomous: true

must_haves:
  truths:
    - "When Claude creates a task, it appears in totui within 1 second"
    - "When Claude updates a task status, totui todo state changes accordingly"
    - "When Claude deletes a task file, the corresponding totui todo is removed"
    - "Header todo displays CLAUDE TASKLIST: {id}"
    - "Synced todos are marked read-only via metadata"
  artifacts:
    - path: "claude-tasks/src/sync.rs"
      provides: "Reconciliation logic between Claude tasks and totui todos"
      exports: ["initial_sync", "process_file_change", "process_file_removal"]
    - path: "claude-tasks/src/commands.rs"
      provides: "FfiCommand builders for create, update, delete operations"
      exports: ["create_todo_commands", "update_todo_command", "delete_todo_command", "create_header_command"]
    - path: "claude-tasks/src/lib.rs"
      provides: "on_event processes sync events and returns FfiCommands"
      contains: "process_sync_events"
  key_links:
    - from: "claude-tasks/src/lib.rs"
      to: "claude-tasks/src/sync.rs"
      via: "on_event calls sync functions"
      pattern: "sync::(initial_sync|process_file)"
    - from: "claude-tasks/src/sync.rs"
      to: "claude-tasks/src/commands.rs"
      via: "sync builds commands for host"
      pattern: "commands::(create_todo|update_todo|delete_todo)"
    - from: "claude-tasks/src/commands.rs"
      to: "totui-plugin-interface"
      via: "FfiCommand generation"
      pattern: "FfiCommand::(CreateTodo|UpdateTodo|DeleteTodo|SetTodoMetadata)"
---

<objective>
Implement the sync engine that reconciles Claude tasks with totui todos, handling create/update/delete operations.

Purpose: Complete the real-time sync loop - file changes trigger todo updates in totui within 1 second.
Output: Full sync logic with metadata correlation, header todo, and read-only marking.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-sync/01-RESEARCH.md
@.planning/phases/01-core-sync/01-CONTEXT.md
@.planning/phases/01-core-sync/01-01-SUMMARY.md
@.planning/phases/01-core-sync/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FfiCommand builders</name>
  <files>claude-tasks/src/commands.rs</files>
  <action>
    Create commands.rs with helper functions for FfiCommand generation:

    1. create_header_command(tasklist_id: &str) -> FfiCommand:
       - Content: "CLAUDE TASKLIST: {tasklist_id}"
       - temp_id: "claude-header-{tasklist_id}"
       - state: FfiTodoState::Empty
       - indent_level: 0

    2. create_todo_commands(task: &ClaudeTask, tasklist_id: &str, header_id: &str) -> Vec<FfiCommand>:
       - CreateTodo command:
         - Content: task.subject (prefix with owner if assigned, ⛔ if blocked)
         - Format blocked tasks: "⛔ {subject}" per CONTEXT.md decision
         - temp_id: "claude-{tasklist_id}-{task.id}"
         - state: map_status_to_state(&task.status)
         - parent_id: header_id
         - indent_level: 1
       - SetTodoMetadata command:
         - todo_id: same temp_id
         - data: JSON object with source, tasklist_id, task_id, read_only, blocked_by
         - merge: false

    3. update_todo_command(task: &ClaudeTask, existing_todo_id: &str) -> FfiCommand:
       - UpdateTodo with id, new content, new state
       - Include blocked indicator in content if task has blockedBy

    4. delete_todo_command(todo_id: &str) -> FfiCommand:
       - DeleteTodo with id

    Reference RESEARCH.md for exact FfiCommand field names and ROption usage.
    Use RString::from() and ROption::RSome/RNone appropriately.
  </action>
  <verify>
    cd claude-tasks && cargo check --lib
  </verify>
  <done>All command builders compile and produce valid FfiCommand instances</done>
</task>

<task type="auto">
  <name>Task 2: Implement sync reconciliation logic</name>
  <files>claude-tasks/src/sync.rs</files>
  <action>
    Create sync.rs with reconciliation functions:

    1. initial_sync(host: &HostApi_TO<'_, RBox<()>>, tasklist_path: &Path, tasklist_id: &str) -> Vec<FfiCommand>:
       - Read all Claude tasks via scan_tasks_directory()
       - Query existing synced todos via host.query_todos_by_metadata("source", "\"claude-tasks\"")
       - Build HashMap of existing todos by task_id (extract from metadata)
       - Create header todo if not exists
       - For each Claude task:
         - If exists in totui: check if update needed (status, subject changed), generate UpdateTodo
         - If not exists: generate CreateTodo + SetTodoMetadata
       - For each existing totui todo not in Claude tasks: generate DeleteTodo
       - Return all commands

    2. process_file_change(host: &HostApi_TO<'_, RBox<()>>, file_path: &Path, tasklist_id: &str, header_id: &str) -> Vec<FfiCommand>:
       - Read and parse the changed JSON file
       - Extract task_id from filename (e.g., "1.json" -> "1")
       - Query for existing todo with this task_id
       - If exists: generate update command if changed
       - If not exists: generate create commands
       - Return commands

    3. process_file_removal(host: &HostApi_TO<'_, RBox<()>>, file_path: &Path, tasklist_id: &str) -> Vec<FfiCommand>:
       - Extract task_id from filename
       - Query for existing todo with this task_id
       - If exists: generate delete command
       - Return commands

    4. needs_update(task: &ClaudeTask, existing: &FfiTodoItem) -> bool:
       - Compare status (map to state), subject (content)
       - Return true if any difference

    Helper: extract_task_id_from_metadata(metadata: &str) -> Option<String>
       - Parse JSON metadata, extract task_id field

    Handle all JSON parse errors gracefully - log and skip, don't panic.
  </action>
  <verify>
    cd claude-tasks && cargo check --lib
  </verify>
  <done>Sync functions compile, handle create/update/delete reconciliation</done>
</task>

<task type="auto">
  <name>Task 3: Wire sync into on_event handler</name>
  <files>claude-tasks/src/lib.rs</files>
  <action>
    Update lib.rs to complete the sync loop:

    1. Add module declarations:
       - mod sync;
       - mod commands;

    2. Implement process_sync_events() helper method on ClaudeTasksPlugin:
       - Takes &self and &HostApi_TO
       - Drains all pending events from rx channel (try_recv in loop)
       - For each event:
         - InitialScan: call sync::initial_sync()
         - FileChanged: call sync::process_file_change()
         - FileRemoved: call sync::process_file_removal()
       - Collect and return all FfiCommands

    3. Update on_event():
       - Match on FfiEvent::OnLoad
       - Call process_sync_events with host from execute_with_host context
       - Return FfiHookResponse with commands

    4. Update execute_with_host():
       - This is called for manual plugin invocation
       - Call process_sync_events() to flush any pending events
       - Return collected commands

    Key insight from RESEARCH.md: on_event is called on OnLoad, which happens when project loads.
    execute_with_host is called when user manually invokes plugin.
    Both should process pending sync events.

    Note: The HostApi is available in on_event via the event parameter for OnLoad events.
    Check totui-plugin-interface for exact API - may need to access host differently.
  </action>
  <verify>
    cd claude-tasks && cargo build --release
  </verify>
  <done>on_event processes sync events, returns FfiCommands to host, sync loop complete</done>
</task>

</tasks>

<verification>
1. `cargo build --release` succeeds
2. Plugin can be loaded by totui (manual test if possible)
3. Initial sync creates header todo and task todos
4. File modifications trigger todo updates
5. File deletions trigger todo removal
6. Todos have read_only: true in metadata
7. Blocked tasks show ⛔ prefix
</verification>

<success_criteria>
- Header todo "CLAUDE TASKLIST: {id}" created on initial sync
- Task todos created with correct state mapping (pending->[], in_progress->[*], completed->[x])
- Metadata tracks source, tasklist_id, task_id, read_only
- Blocked tasks prefixed with ⛔
- Updates detected and applied when task files change
- Deletions handled when task files removed
- All operations complete within 1 second of file change (debounce + processing)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-sync/01-03-SUMMARY.md`
</output>
