---
phase: 01-core-sync
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - claude-tasks/src/state.rs
  - claude-tasks/src/sync.rs
  - claude-tasks/src/lib.rs
  - claude-tasks/Cargo.toml
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "on_event returns FfiHookResponse with sync commands"
    - "known_tasks HashSet tracks synced tasks locally without HostApi"
    - "Real-time sync works via on_event hook automatically"
  artifacts:
    - path: "claude-tasks/src/state.rs"
      provides: "Local task tracking (known_tasks HashSet)"
      min_lines: 60
    - path: "claude-tasks/src/sync.rs"
      provides: "HostApi-free sync functions"
      contains: "process_initial_scan_local"
    - path: "claude-tasks/src/lib.rs"
      provides: "on_event returns FfiHookResponse with commands"
      pattern: "FfiHookResponse.*commands"
  key_links:
    - from: "claude-tasks/src/lib.rs"
      to: "on_event"
      via: "FfiHookResponse with commands"
      pattern: "commands:\\s*commands\\.into"
    - from: "claude-tasks/src/lib.rs"
      to: "claude-tasks/src/state.rs"
      via: "process_sync_events_local updates known_tasks"
      pattern: "(mark_task_known|forget_task|is_task_known)"
    - from: "claude-tasks/src/state.rs"
      to: "is_task_known"
      via: "Local state check before HostApi query"
      pattern: "is_task_known\\(&self.*->\\s*bool"
---

<objective>
Fix the real-time sync gap by enabling on_event to return commands without HostApi access.

Purpose: Close the critical verification gap - sync logic exists but never executes because on_event returns empty. The fix uses predictable todo IDs and local state tracking to avoid HostApi dependency.

Output: Plugin syncs Claude tasks to totui automatically via on_event, not just manual execute_with_host invocation.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-sync/01-03-SUMMARY.md
@.planning/phases/01-core-sync/01-VERIFICATION.md

Source files being modified:
@claude-tasks/src/state.rs
@claude-tasks/src/sync.rs
@claude-tasks/src/lib.rs
@claude-tasks/src/commands.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add local task tracking to SyncState</name>
  <files>claude-tasks/src/state.rs</files>
  <action>
    Extend SyncState to track which task_ids have been synced locally:

    1. Add new field to SyncState:
       ```rust
       /// Set of task IDs that have been synced to totui.
       /// Used to determine if we should create vs update without querying HostApi.
       pub known_tasks: HashSet<String>,
       ```

    2. Add import at top:
       ```rust
       use std::collections::HashSet;
       ```

    3. Update Default impl to initialize empty HashSet:
       ```rust
       impl Default for SyncState {
           fn default() -> Self {
               Self {
                   selected_tasklist: None,
                   header_todo_id: None,
                   known_tasks: HashSet::new(),
               }
           }
       }
       ```

    4. Add helper methods:
       ```rust
       impl SyncState {
           /// Mark a task as known (synced to totui)
           pub fn mark_task_known(&mut self, task_id: &str) {
               self.known_tasks.insert(task_id.to_string());
           }

           /// Check if a task is known (already synced)
           pub fn is_task_known(&self, task_id: &str) -> bool {
               self.known_tasks.contains(task_id)
           }

           /// Remove a task from known set (after deletion)
           pub fn forget_task(&mut self, task_id: &str) {
               self.known_tasks.remove(task_id);
           }

           /// Clear all known tasks (for resync)
           pub fn clear_known_tasks(&mut self) {
               self.known_tasks.clear();
           }
       }
       ```

    5. Add tests:
       ```rust
       #[test]
       fn test_known_tasks_tracking() {
           let mut state = SyncState::default();
           assert!(!state.is_task_known("1"));

           state.mark_task_known("1");
           assert!(state.is_task_known("1"));

           state.forget_task("1");
           assert!(!state.is_task_known("1"));
       }

       #[test]
       fn test_clear_known_tasks() {
           let mut state = SyncState::default();
           state.mark_task_known("1");
           state.mark_task_known("2");

           state.clear_known_tasks();
           assert!(!state.is_task_known("1"));
           assert!(!state.is_task_known("2"));
       }
       ```
  </action>
  <verify>
    cd /Users/gimmi/Documents/Sources/rust/to-tui-plugins/claude-tasks && cargo test test_known_tasks_tracking --lib && cargo test test_clear_known_tasks --lib
  </verify>
  <done>SyncState has known_tasks HashSet with mark_task_known, is_task_known, forget_task, clear_known_tasks methods. All state tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create HostApi-free sync functions</name>
  <files>claude-tasks/src/sync.rs, claude-tasks/Cargo.toml</files>
  <action>
    First, add tempfile to dev-dependencies for testing:

    In claude-tasks/Cargo.toml, add under [dev-dependencies]:
    ```toml
    tempfile = "3"
    ```

    Then add new sync functions that work without HostApi by using local state tracking:

    1. Add new function for initial scan without HostApi:
       ```rust
       /// Process initial scan using local state tracking (no HostApi needed).
       ///
       /// Reads all Claude task files and generates create commands.
       /// Tracks created tasks in known_tasks set.
       /// Returns commands and set of task_ids found.
       pub fn process_initial_scan_local(
           tasklist_path: &Path,
           tasklist_id: &str,
       ) -> (Vec<FfiCommand>, Vec<String>) {
           let mut commands = Vec::new();
           let mut task_ids = Vec::new();

           // Read all Claude tasks from directory
           let claude_tasks = scan_tasks_directory(tasklist_path);

           // Create header
           let hdr_id = header_id(tasklist_id);
           commands.push(create_header_command(tasklist_id));

           // Create todos for all tasks
           for task in &claude_tasks {
               task_ids.push(task.id.clone());
               commands.extend(create_todo_commands(task, tasklist_id, &hdr_id));
           }

           (commands, task_ids)
       }
       ```

    2. Add function for file change without HostApi:
       ```rust
       /// Process file change using local state tracking (no HostApi needed).
       ///
       /// If task_id is known, generates update command.
       /// If task_id is new, generates create commands.
       /// Returns (commands, task_id, is_new).
       pub fn process_file_change_local(
           file_path: &Path,
           tasklist_id: &str,
           is_known: bool,
       ) -> Option<(Vec<FfiCommand>, String)> {
           // Extract task_id from filename
           let task_id = extract_task_id_from_path(file_path)?;

           // Read and parse task file
           let content = std::fs::read_to_string(file_path).ok()?;
           let task: ClaudeTask = serde_json::from_str(&content).ok()?;

           let mut commands = Vec::new();
           let hdr_id = header_id(tasklist_id);

           if is_known {
               // Update existing - use predictable todo ID
               let todo_id = task_todo_id(tasklist_id, &task_id);
               commands.push(update_todo_command(&task, &todo_id));
           } else {
               // Create new
               commands.extend(create_todo_commands(&task, tasklist_id, &hdr_id));
           }

           Some((commands, task_id))
       }
       ```

    3. Add function for file removal without HostApi:
       ```rust
       /// Process file removal using predictable todo ID (no HostApi needed).
       ///
       /// Returns (command, task_id) if file was a task file.
       pub fn process_file_removal_local(
           file_path: &Path,
           tasklist_id: &str,
       ) -> Option<(FfiCommand, String)> {
           let task_id = extract_task_id_from_path(file_path)?;
           let todo_id = task_todo_id(tasklist_id, &task_id);
           Some((delete_todo_command(&todo_id), task_id))
       }
       ```

    4. Add import for task_todo_id (note: task_todo_id already exists in commands.rs from Plan 03, just add to import):
       ```rust
       use crate::commands::{
           create_header_command, create_todo_commands, delete_todo_command, header_id,
           update_todo_command, task_todo_id,
       };
       ```

    5. Add comprehensive tests for all three new functions:
       ```rust
       #[test]
       fn test_process_initial_scan_local_empty_dir() {
           // Create temp dir with no tasks
           let dir = tempfile::tempdir().unwrap();
           let (cmds, task_ids) = process_initial_scan_local(dir.path(), "test-list");

           // Should have header command only, no tasks
           assert_eq!(cmds.len(), 1); // just header
           assert!(task_ids.is_empty());
           match &cmds[0] {
               FfiCommand::CreateTodo { content, .. } => {
                   assert!(content.as_str().contains("CLAUDE TASKLIST"));
               }
               _ => panic!("Expected CreateTodo for header"),
           }
       }

       #[test]
       fn test_process_initial_scan_local_with_tasks() {
           let dir = tempfile::tempdir().unwrap();
           // Create test task file
           let task = ClaudeTask {
               id: "1".to_string(),
               subject: "Test".to_string(),
               description: String::new(),
               active_form: String::new(),
               status: "pending".to_string(),
               blocks: vec![],
               blocked_by: vec![],
           };
           std::fs::write(
               dir.path().join("1.json"),
               serde_json::to_string(&task).unwrap(),
           ).unwrap();

           let (cmds, task_ids) = process_initial_scan_local(dir.path(), "test-list");

           // Should have header + create + metadata commands
           assert!(cmds.len() >= 2); // header + at least create
           assert_eq!(task_ids, vec!["1"]);
       }

       #[test]
       fn test_process_file_change_local_known_task() {
           let dir = tempfile::tempdir().unwrap();
           let task_path = dir.path().join("1.json");
           let task = ClaudeTask {
               id: "1".to_string(),
               subject: "Updated task".to_string(),
               description: String::new(),
               active_form: String::new(),
               status: "completed".to_string(),
               blocks: vec![],
               blocked_by: vec![],
           };
           std::fs::write(&task_path, serde_json::to_string(&task).unwrap()).unwrap();

           let result = process_file_change_local(&task_path, "tasklist-1", true);
           let (cmds, task_id) = result.unwrap();

           assert_eq!(task_id, "1");
           assert_eq!(cmds.len(), 1); // single update command
           match &cmds[0] {
               FfiCommand::UpdateTodo { id, .. } => {
                   assert_eq!(id.as_str(), "claude-tasklist-1-1");
               }
               _ => panic!("Expected UpdateTodo for known task"),
           }
       }

       #[test]
       fn test_process_file_change_local_unknown_task() {
           let dir = tempfile::tempdir().unwrap();
           let task_path = dir.path().join("2.json");
           let task = ClaudeTask {
               id: "2".to_string(),
               subject: "New task".to_string(),
               description: String::new(),
               active_form: String::new(),
               status: "pending".to_string(),
               blocks: vec![],
               blocked_by: vec![],
           };
           std::fs::write(&task_path, serde_json::to_string(&task).unwrap()).unwrap();

           let result = process_file_change_local(&task_path, "tasklist-1", false);
           let (cmds, task_id) = result.unwrap();

           assert_eq!(task_id, "2");
           assert_eq!(cmds.len(), 2); // create + metadata commands
           match &cmds[0] {
               FfiCommand::CreateTodo { temp_id, .. } => {
                   assert!(matches!(temp_id, ROption::RSome(ref s) if s.as_str() == "claude-tasklist-1-2"));
               }
               _ => panic!("Expected CreateTodo for unknown task"),
           }
       }

       #[test]
       fn test_process_file_removal_local() {
           let result = process_file_removal_local(
               Path::new("/path/to/1.json"),
               "tasklist-1",
           );

           let (cmd, task_id) = result.unwrap();
           assert_eq!(task_id, "1");
           match cmd {
               FfiCommand::DeleteTodo { id } => {
                   assert_eq!(id.as_str(), "claude-tasklist-1-1");
               }
               _ => panic!("Expected DeleteTodo"),
           }
       }

       #[test]
       fn test_process_file_removal_local_non_task_file() {
           // Non-JSON file should return None
           let result = process_file_removal_local(
               Path::new("/path/to/readme.txt"),
               "tasklist-1",
           );
           assert!(result.is_none());
       }
       ```
  </action>
  <verify>
    cd /Users/gimmi/Documents/Sources/rust/to-tui-plugins/claude-tasks && cargo tree -i tempfile --depth 0 && cargo test sync:: --lib
  </verify>
  <done>New HostApi-free sync functions exist: process_initial_scan_local, process_file_change_local, process_file_removal_local. tempfile dev-dependency added. All sync tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: Wire on_event to return commands</name>
  <files>claude-tasks/src/lib.rs</files>
  <action>
    Update on_event to process sync events and return commands via FfiHookResponse:

    1. Add new method to ClaudeTasksPlugin for processing events without HostApi:
       ```rust
       /// Process all pending sync events using local state tracking.
       ///
       /// Unlike process_sync_events, this doesn't need HostApi - it uses
       /// local known_tasks tracking to determine create vs update.
       fn process_sync_events_local(&self) -> Vec<FfiCommand> {
           let mut commands = Vec::new();

           // Get tasklist info from state
           let (tasklist_path, tasklist_id) = {
               let state = self.state.lock().unwrap();
               match &state.selected_tasklist {
                   Some(path) => {
                       let id = path
                           .file_name()
                           .and_then(|n| n.to_str())
                           .unwrap_or("unknown")
                           .to_string();
                       (path.clone(), id)
                   }
                   None => return commands,
               }
           };

           // Drain all pending events from channel
           let rx_guard = self.rx.lock().unwrap();
           let Some(rx) = rx_guard.as_ref() else {
               return commands;
           };

           // Collect events first (to minimize lock time on state)
           let mut events = Vec::new();
           loop {
               match rx.try_recv() {
                   Ok(event) => events.push(event),
                   Err(mpsc::TryRecvError::Empty) => break,
                   Err(mpsc::TryRecvError::Disconnected) => {
                       eprintln!("claude-tasks: Watcher channel disconnected");
                       break;
                   }
               }
           }
           drop(rx_guard);

           // Process events
           for event in events {
               match event {
                   SyncEvent::InitialScan => {
                       let (cmds, task_ids) = sync::process_initial_scan_local(
                           &tasklist_path,
                           &tasklist_id,
                       );
                       commands.extend(cmds);

                       // Mark all tasks as known
                       let mut state = self.state.lock().unwrap();
                       state.clear_known_tasks();
                       for id in task_ids {
                           state.mark_task_known(&id);
                       }
                   }
                   SyncEvent::FileChanged(path) => {
                       let is_known = {
                           let state = self.state.lock().unwrap();
                           // Extract task_id from path to check if known
                           path.file_stem()
                               .and_then(|s| s.to_str())
                               .map(|id| state.is_task_known(id))
                               .unwrap_or(false)
                       };

                       if let Some((cmds, task_id)) = sync::process_file_change_local(
                           &path,
                           &tasklist_id,
                           is_known,
                       ) {
                           commands.extend(cmds);

                           // Mark as known if new
                           if !is_known {
                               let mut state = self.state.lock().unwrap();
                               state.mark_task_known(&task_id);
                           }
                       }
                   }
                   SyncEvent::FileRemoved(path) => {
                       if let Some((cmd, task_id)) = sync::process_file_removal_local(
                           &path,
                           &tasklist_id,
                       ) {
                           commands.push(cmd);

                           // Forget the task
                           let mut state = self.state.lock().unwrap();
                           state.forget_task(&task_id);
                       }
                   }
               }
           }

           commands
       }
       ```

    2. Update on_event to call process_sync_events_local and return commands:
       ```rust
       fn on_event(&self, event: FfiEvent) -> RResult<FfiHookResponse, RString> {
           if let FfiEvent::OnLoad { .. } = event {
               // Process pending sync events and return commands
               let commands = self.process_sync_events_local();

               if !commands.is_empty() {
                   eprintln!("claude-tasks: on_event returning {} commands", commands.len());
               }

               return RResult::ROk(FfiHookResponse {
                   commands: commands.into_iter().collect(),
               });
           }

           RResult::ROk(FfiHookResponse::default())
       }
       ```

    3. Keep execute_with_host for backward compatibility but have it also use local processing:
       ```rust
       fn execute_with_host(
           &self,
           _input: RString,
           _host: HostApi_TO<'_, RBox<()>>,
       ) -> RResult<RVec<FfiCommand>, RString> {
           // Process sync events using local state (same as on_event)
           // This allows manual plugin invocation to also work
           let commands = self.process_sync_events_local();
           RResult::ROk(commands.into_iter().collect())
       }
       ```

    4. Remove or deprecate the old process_sync_events method that requires HostApi:
       - If process_sync_events exists (from Plan 03), either:
         a. Delete it entirely if no longer needed
         b. Or mark it #[deprecated] with note "Use process_sync_events_local instead - no HostApi required"
       - Update any remaining callers to use process_sync_events_local instead
       - The goal is to eliminate HostApi dependency in the sync path

    5. Run cargo fmt and cargo clippy to clean up.
  </action>
  <verify>
    cd /Users/gimmi/Documents/Sources/rust/to-tui-plugins/claude-tasks && cargo build --release && cargo test --lib
  </verify>
  <done>on_event returns FfiHookResponse with commands from process_sync_events_local. All tests pass. Plugin builds as cdylib.</done>
</task>

</tasks>

<verification>
1. `cargo build --release` succeeds without warnings
2. `cargo test --lib` passes all tests (existing + new)
3. The on_event function returns FfiHookResponse with non-empty commands
4. Code review confirms:
   - SyncState has known_tasks tracking
   - process_initial_scan_local, process_file_change_local, process_file_removal_local exist
   - on_event calls process_sync_events_local and returns commands
</verification>

<success_criteria>
- When watcher detects file changes, on_event returns commands to create/update/delete todos
- No HostApi dependency in the sync path (uses local state tracking)
- All 38+ existing tests still pass
- New tests for local state tracking pass
- Plugin compiles as cdylib
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-sync/01-04-SUMMARY.md`
</output>
