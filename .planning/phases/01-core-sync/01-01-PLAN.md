---
phase: 01-core-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - claude-tasks/Cargo.toml
  - claude-tasks/src/lib.rs
  - claude-tasks/src/claude_task.rs
  - claude-tasks/src/state.rs
autonomous: true

must_haves:
  truths:
    - "Plugin compiles as cdylib targeting totui-plugin-interface"
    - "ClaudeTask struct can parse JSON from ~/.claude/tasks/{uuid}/*.json"
    - "Status mapping converts pending/in_progress/completed to FfiTodoState"
  artifacts:
    - path: "claude-tasks/Cargo.toml"
      provides: "Project manifest with all Phase 1 dependencies"
      contains: "notify-debouncer-full"
    - path: "claude-tasks/src/lib.rs"
      provides: "Plugin entry point and trait implementation"
      exports: ["get_library", "ClaudeTasksPlugin"]
    - path: "claude-tasks/src/claude_task.rs"
      provides: "ClaudeTask struct with serde deserialization"
      contains: "struct ClaudeTask"
    - path: "claude-tasks/src/state.rs"
      provides: "SyncState and SyncEvent types for shared state"
      contains: "struct SyncState"
  key_links:
    - from: "claude-tasks/src/lib.rs"
      to: "totui-plugin-interface"
      via: "Plugin trait implementation"
      pattern: "impl Plugin for ClaudeTasksPlugin"
---

<objective>
Create the claude-tasks plugin scaffolding with project structure, dependencies, Plugin trait implementation, and core data types.

Purpose: Establish the foundation that all subsequent plans build upon - the plugin compiles and exposes the correct FFI interface.
Output: Compilable Rust cdylib plugin with ClaudeTask parsing and status mapping.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-sync/01-RESEARCH.md
@jira-claude/Cargo.toml (reference for plugin structure)
@jira-claude/src/lib.rs (reference for Plugin trait pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project structure and Cargo.toml</name>
  <files>claude-tasks/Cargo.toml</files>
  <action>
    Create the claude-tasks directory and Cargo.toml with all Phase 1 dependencies:

    - totui-plugin-interface from git (main branch)
    - abi_stable 0.11
    - serde 1.0 with derive feature
    - serde_json 1.0
    - notify 8
    - notify-debouncer-full 0.7
    - uuid 1.20 with v4 feature
    - dirs 6

    Set crate-type to cdylib for dynamic library output.
    Follow the jira-claude Cargo.toml pattern but add the file watching dependencies.
  </action>
  <verify>
    cd claude-tasks && cargo check --lib
  </verify>
  <done>Cargo.toml exists with all dependencies and cargo check passes</done>
</task>

<task type="auto">
  <name>Task 2: Implement ClaudeTask struct and state types</name>
  <files>claude-tasks/src/claude_task.rs, claude-tasks/src/state.rs</files>
  <action>
    Create claude_task.rs with:
    - ClaudeTask struct matching JSON schema: id, subject, description, activeForm, status, blocks, blockedBy
    - Use #[serde(rename = "activeForm")] and #[serde(rename = "blockedBy")]
    - Use #[serde(default)] for blocks and blockedBy vectors
    - map_status_to_state() function: pending->Empty, in_progress->InProgress, completed->Checked

    Create state.rs with:
    - SyncEvent enum: FileChanged(PathBuf), FileRemoved(PathBuf), InitialScan
    - SyncState struct: selected_tasklist (Option<PathBuf>), header_todo_id (Option<String>)
    - Wrap SyncState in Mutex for thread-safe access

    Reference RESEARCH.md code examples for exact field names and status mapping.
  </action>
  <verify>
    cd claude-tasks && cargo check --lib
  </verify>
  <done>ClaudeTask parses JSON correctly, SyncState compiles with Mutex wrapper</done>
</task>

<task type="auto">
  <name>Task 3: Implement Plugin trait skeleton</name>
  <files>claude-tasks/src/lib.rs</files>
  <action>
    Create lib.rs with:
    - Module declarations: mod claude_task; mod state;
    - get_library() export using #[export_root_module] macro
    - create_plugin() extern "C" function
    - ClaudeTasksPlugin struct with:
      - rx: Mutex<Option<mpsc::Receiver<SyncEvent>>> for watcher events
      - tx: Mutex<Option<mpsc::Sender<SyncEvent>>> for watcher thread
      - state: Mutex<SyncState> for shared state
    - Plugin trait implementation with stub methods:
      - name() -> "claude-tasks"
      - version() -> "0.1.0"
      - min_interface_version() -> "0.1.0"
      - generate() -> empty RVec (not used by this plugin)
      - config_schema() -> empty schema
      - execute_with_host() -> empty commands
      - on_config_loaded() -> no-op (will be implemented in Plan 02)
      - subscribed_events() -> subscribe to OnLoad
      - on_event() -> no-op (will be implemented in Plan 03)

    Follow jira-claude/src/lib.rs pattern for abi_stable imports and module export.
  </action>
  <verify>
    cd claude-tasks && cargo build --release
    ls claude-tasks/target/release/*.dylib || ls claude-tasks/target/release/*.so
  </verify>
  <done>Plugin compiles as cdylib, exports get_library function</done>
</task>

</tasks>

<verification>
1. `cd claude-tasks && cargo build --release` succeeds
2. Dynamic library exists in target/release/
3. `cargo test` passes (if any unit tests exist)
4. ClaudeTask can deserialize sample JSON: `{"id":"1","subject":"Test","description":"Desc","activeForm":"Testing","status":"pending","blocks":[],"blockedBy":[]}`
</verification>

<success_criteria>
- claude-tasks/ directory exists with proper Rust project structure
- All Phase 1 dependencies declared in Cargo.toml
- Plugin compiles as cdylib without errors
- ClaudeTask struct matches Claude Code's JSON schema
- Status mapping function converts all three statuses correctly
- SyncState and SyncEvent types ready for watcher integration
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-sync/01-01-SUMMARY.md`
</output>
