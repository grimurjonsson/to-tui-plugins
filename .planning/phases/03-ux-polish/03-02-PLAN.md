---
phase: 03-ux-polish
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - claude-tasks/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "User sees setup guidance when no tasklists exist"
    - "User sees waiting guidance when tasklist is empty"
    - "Guidance automatically clears when real tasks arrive"
    - "Error states show actionable recovery guidance"
  artifacts:
    - path: "claude-tasks/src/lib.rs"
      provides: "Integrated guidance lifecycle in plugin"
      contains: "guidance::"
  key_links:
    - from: "claude-tasks/src/lib.rs"
      to: "claude-tasks/src/guidance.rs"
      via: "guidance::create_* and guidance::clear_guidance calls"
      pattern: "guidance::create_"
    - from: "on_config_loaded"
      to: "state.set_guidance"
      via: "Initial guidance state setup"
      pattern: "state.set_guidance"
---

<objective>
Integrate guidance todos into the plugin lifecycle so users see contextual help in various states.

Purpose: Users will see clear, actionable guidance in the TUI when the plugin loads but can't sync tasks yet. This addresses the user feedback that the plugin "installs but unclear how to use."

Output: on_config_loaded shows appropriate guidance, guidance clears when sync begins, errors show recovery guidance.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/03-ux-polish/03-RESEARCH.md
@.planning/phases/03-ux-polish/03-01-SUMMARY.md
@claude-tasks/src/lib.rs
@claude-tasks/src/state.rs
@claude-tasks/src/guidance.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pending_commands field to SyncState for deferred command delivery</name>
  <files>claude-tasks/src/state.rs</files>
  <action>
Add a new field to SyncState for storing commands that need to be returned on the next on_event call:

```rust
/// Commands to return on next on_event call.
/// Used for guidance commands created during on_config_loaded.
pub pending_commands: Vec<FfiCommand>,
```

This is needed because on_config_loaded returns void - we can't return commands directly. Instead, we store them and return them on the next on_event(OnLoad).

Add import at top: `use totui_plugin_interface::FfiCommand;`

Update the Default derivation - Vec<FfiCommand> implements Default (empty vec).

Add helper methods:
- `take_pending_commands(&mut self) -> Vec<FfiCommand>` - returns and clears pending_commands
- `has_pending_commands(&self) -> bool` - returns !pending_commands.is_empty()

Add tests for pending_commands handling.
  </action>
  <verify>cargo test --package claude-tasks state:: -- --nocapture</verify>
  <done>pending_commands field added, helper methods work, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Integrate guidance into on_config_loaded</name>
  <files>claude-tasks/src/lib.rs</files>
  <action>
Modify on_config_loaded to show guidance for various states:

1. **Import guidance module functions** at top with other imports:
```rust
use guidance::{create_no_tasklist_guidance, create_empty_tasklist_guidance, clear_guidance};
```

2. **When no tasklists found** (replace current eprintln-only handling):
```rust
if tasklists.is_empty() {
    eprintln!("claude-tasks: No tasklists found - showing setup guidance");
    let mut state = self.state.lock().unwrap();
    state.pending_commands = create_no_tasklist_guidance();
    state.set_guidance(GuidanceState::NoTasklists);
    return;
}
```

3. **After selecting tasklist, check if empty** (after watcher starts successfully):
After the watcher setup succeeds and before sending InitialScan, add a check for empty tasklist:
```rust
// Check if tasklist has any tasks - if empty, show waiting guidance
let tasks = discovery::scan_tasks_directory(&selected.path);
if tasks.is_empty() {
    let display_name = format_tasklist_display(&selected.id, &plugin_config);
    let mut state = self.state.lock().unwrap();
    state.pending_commands = create_empty_tasklist_guidance(&display_name);
    state.set_guidance(GuidanceState::EmptyTasklist);
    eprintln!("claude-tasks: Empty tasklist - showing waiting guidance");
}
```

4. **On watcher error**, show error guidance:
```rust
Err(e) => {
    let error_msg = e.to_string();
    eprintln!("claude-tasks: Failed to start watcher: {}", error_msg);
    let mut state = self.state.lock().unwrap();
    state.pending_commands = guidance::create_error_guidance(
        "CLAUDE TASKS - Watcher Failed",
        &error_msg,
        "Restart totui to retry"
    );
    state.set_guidance(GuidanceState::Error);
    return;
}
```

Add import for GuidanceState:
```rust
use state::{new_shared_state, SharedSyncState, SyncEvent, GuidanceState};
```
  </action>
  <verify>cargo check --package claude-tasks</verify>
  <done>on_config_loaded sets guidance state and pending_commands for all three cases (no tasklists, empty tasklist, watcher error)</done>
</task>

<task type="auto">
  <name>Task 3: Integrate guidance delivery and clearing in on_event</name>
  <files>claude-tasks/src/lib.rs</files>
  <action>
Modify on_event to:

1. **Return pending guidance commands** at the start of OnLoad handling:
```rust
fn on_event(&self, event: FfiEvent) -> RResult<FfiHookResponse, RString> {
    if let FfiEvent::OnLoad { .. } = event {
        // Check for pending guidance commands first
        let pending = {
            let mut state = self.state.lock().unwrap();
            state.take_pending_commands()
        };

        if !pending.is_empty() {
            eprintln!("claude-tasks: Returning {} pending guidance commands", pending.len());
            return RResult::ROk(FfiHookResponse {
                commands: pending.into_iter().collect(),
            });
        }

        // Continue with normal sync processing...
```

2. **Clear guidance when real tasks sync** in process_sync_events_local:
At the start of process_sync_events_local, after collecting events but before processing them:
```rust
// Clear guidance when we have real events to process
let should_clear_guidance = {
    let state = self.state.lock().unwrap();
    state.is_guidance_shown() && !events.is_empty()
};

if should_clear_guidance {
    // Prepend guidance clear commands
    let clear_cmds = clear_guidance();
    commands.extend(clear_cmds);

    // Update state
    let mut state = self.state.lock().unwrap();
    state.clear_guidance();
    eprintln!("claude-tasks: Clearing guidance - real tasks arrived");
}
```

Import clear_guidance at top if not already imported.
  </action>
  <verify>cargo check --package claude-tasks && cargo test --package claude-tasks</verify>
  <done>on_event returns pending guidance commands, guidance clears when real sync begins</done>
</task>

</tasks>

<verification>
Run the full test suite:
```bash
cargo test --package claude-tasks
```

Verify integration points:
```bash
grep -n "guidance::" claude-tasks/src/lib.rs
grep -n "pending_commands" claude-tasks/src/lib.rs
grep -n "GuidanceState" claude-tasks/src/lib.rs
```

Check for compilation warnings:
```bash
cargo clippy --package claude-tasks -- -D warnings
```

Expected: All tests pass, no warnings, guidance functions called in appropriate places.
</verification>

<success_criteria>
- [ ] pending_commands field exists in SyncState
- [ ] on_config_loaded creates guidance for: no tasklists, empty tasklist, watcher error
- [ ] on_event returns pending guidance commands on first OnLoad
- [ ] process_sync_events_local clears guidance when real events arrive
- [ ] All existing tests still pass (78+)
- [ ] No clippy warnings
- [ ] Crate compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-ux-polish/03-02-SUMMARY.md`
</output>
